m4_define(`m4_post_date', `2008-12-20')m4_dnl
m4_define(`m4_post_title', `Decision Tables')m4_dnl
m4_include(`posttrans.m4')m4_dnl
m4_begin_post
<p>
I still see a lot of code with complicated <code>if-then-else</code> conditions that can be simplified quite a bit by the simple technique of using <a href="http://en.wikipedia.org/wiki/Decision_table">decision tables</a>. A decision table is a compact yet exhaustive way of encoding conditions and the actions to be taken under those conditions. The rows and columns of a decision table denote the conditions and the cells denote the actions. Since it simplifies complicated conditional logic, it can make your code a lot easier to maintain and a lot less error-prone.
m4_begin_post_rest
<p>
Decision tables come in many forms. The exact structure of an optimal decision table will depend on the particular problem being solved. For example, if you are writing an interpreter for a virtual machine with single-byte <a href="http://en.wikipedia.org/wiki/Opcode">opcodes</a> where most of the 255 possible values stand for valid instructions, you can simply construct a table with 255 pointers to instruction-specific interpreter functions. In this case, if you have written the <code>interpretAdd( )</code> function to interpret the <code>ADD</code> instruction with opcode, say, "<code>23</code>", the 23<sup>rd</sup> position in the decision table (counting from 0) will be a pointer to the <code>interpretAdd( )</code> function. The core of the interpreter loop then simply fetches the next byte and calls the function at the position in the decision table indicated by the value of the byte.
<p>
Let us consider another example (taken from <a href="http://smlnj.org/icfp08-contest/task.html">the task description for ICFPC 2008</a>). Suppose you are writing the steering-control logic for a Martian rover in Java. The rover moves around on Mars avoiding boulders, craters and evil Martians with a goal of reaching its home base as quickly as possible. The steering-control logic for the rover has to compute the desired direction of motion relative to the current direction of motion and turn the axle accordingly.
<p>
The axle of the rover could be in one of the following possible orientations:<br /><pre>private static final int TURN_STATE_HARD_LEFT = 0;<br />private static final int TURN_STATE_LEFT = 1;<br />private static final int TURN_STATE_STRAIGHT = 2;<br />private static final int TURN_STATE_RIGHT = 3;<br />private static final int TURN_STATE_HARD_RIGHT = 4;<br /></pre><br />Based on the environment and the goal, your steering-control logic determines one of the following courses of action to move in the desired direction relative to the current direction of motion:<br /><pre>private static final int STEER_LEFT = 0;<br />private static final int STEER_FORWARD = 1;<br />private static final int STEER_RIGHT = 2;<br />private static final int STEER_BACKWARD = 3;<br /></pre><br />The output of your steering-control logic has to be one of "<code>l</code>", "<code>-</code>" or "<code>r</code>" denoting a command to "turn the axle further left", "not change the axle orientation" or "turn the axle further right" respectively. You can then construct a decision table like the following to get an appropriate command based on the current orientation of the axle and the desired direction of motion:<br /><pre>private char[][] steerDecTable<br />= {<br />/* LEFT, FORWARD, RIGHT, BACKWARD */<br />/* HARD_LEFT */  {   '-',   'r',     'r',   '-'},<br />/* LEFT */       {   '-',   'r',     'r',   'l'},<br />/* STRAIGHT */   {   'l',   '-',     'r',   'r'},<br />/* RIGHT */      {   'l',   'l',     '-',   'r'},<br />/* HARD_RIGHT */ {   'l',   'l',     '-',   '-'},<br />};<br /></pre><br />The rows of this table denote the current orientation of the axle and the columns denote the desired direction of motion. Note that the values of our named constants have been selected to match the corresponding indices in this table.
<p>
With this decision table in hand, the core of our steering-control logic simply becomes:<br /><pre>char steerChar = steerDecTable[curTurnState][steer];<br /></pre><br />"<code>curTurnState</code>" denotes the current orientation of the axle and has one of the values denoted by the "<code>TURN_STATE_XXX</code>" named constants. "<code>steer</code>" denotes the desired direction of motion and has one of the values denoted by the "<code>STEER_XXX</code>" named constants.
<p>
Think about how you would have written this logic without using a decision table.
<p>
<b>Update (2010-02-24):</b> The chapter on table-driven methods in the book "<a href="https://rmathew.com/2010/cc2e.html">Code Complete</a>" by Steve McConnell contains more details on this technique.
<p>
(<a href="https://rmathew.blogspot.com/2008/12/decision-tables.html">Originally posted on Blogspot</a>.)
m4_end_post_rest
m4_end_post
